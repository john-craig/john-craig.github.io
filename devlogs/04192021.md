**4/19** <br/>
 So the first thing I want to set up self-hosting wise is a service called Bitwarden. This is a password manager which works across different platforms, and I consider it to be fairly high-priority, because having convenient access to a password manager is instrumental to the security of everything else that I do.
 Though I was able to get the docker image for Bitwarden up and running easily enough, actually creating your master account requires an HTTPS connection, which I do not have configured for Nginx. HTTPS connections require an SSL certificate, which can be provided by a service called “Let’s Encrypt”, which is itself built into Nginx Proxy Manager; I assumed it would be as simple as flipping a switch to turn it on for all the reverse-proxies I’m using.
 Apparently, not so! There needs to be something called a DNS challenge, which I don’t know anything about, except that you can get them from your upstream DNS provider if you do some setup. I’m willing to bet there is a way to set them up on your own network though, and I’m more inclined to do the legwork for that and continue to keep everything in-house, rather than go out-of-network for this one thing.
 Before I start on that, though, I have a game application to finish. I have decided that rather than hopping from project to project, adjusting minor bits and bobs here and there, like some kind of methamphetamine-crazed squirrel, I should instead pick one thing to focus on at a time.
 This has proven to be pretty effective, I think. There are some activities you can chip away at by just devoting a few minutes a day towards it-- practicing a guitar or learning to draw, for instance-- but when it comes to programming, sustained concentration until completion is more the way to go.
 The only downside to this is that the next project on my list is this game application for a mobile design class. And, I mean, it’s not terrible-- there are interesting challenges here, too. There is a slight inconvenience with the development process now, though, because most of the features I’m trying to implement-- rotation sensing and heat sensing-- need to be tested out on the physical device, as opposed to just being run in an emulator. So I have to build the whole application and get it onto my phone each time that I want to try out a new change.
 Life goes on.

**4/20** <br/>
 Anyways, I believe I got the sensors for this mobile application implemented correctly. I say “believe” because I haven’t tested it yet. Yesterday I was pretty sure that I would need to install the application on a physical device to try out the changes, and I will still probably want to do that at some point. However, looking around online I was able to find that the emulator on Android Studio actually does have facilities for simulating motion and temperature, so I am inclined to just use that for now.
 It goes to show that spending a little bit of time doing the legwork and making sure you’ve really exhausted all your options can save you a lot of time as a developer. I mean, fingers crossed that I got all the implementations right the first time and would have only needed to test it once on a physical device anyways, but… fingers cross, circuits scoff.

**4/21** <br/>
 It seems like, with a few small tweaks, I have everything working alright. I was able to try some of the sensor out in the emulator and I got the results that I was looking for. I may have to tweak the values for the gyroscope… it’s been a while since I took physics and if you asked me what angular velocity is, I’d probably blurt out something about cosigns and change the subject.
 The impact here is the level of rotation necessary for the game to change the direction of the crossbow. And, now that I think about it, it will probably be more a matter of angular acceleration, not velocity. But it doesn’t matter, I’m not going to bust of a bunch of physics equations. I’ll just mess around the threshhold around until it hits a level I like.
 The thing I’m more excited about is the temperature sensor. My plan is for the graphics and background of the game to change different colors based on the temperature; if it’s cold in the room you’re playing, the game will have more of an arctic-type theme, whereas if it’s warm it will be more of a desert theme. Figuring out how to make that happen should be interesting.

**4/22** <br/>
 I sort of broke my rule about staying on-track. I reasoned to myself, “We have enough of the framework for the sensors built up in the mobile application, we can work on something else.” This was a mistake. If you’re ever not drinking coffee for long enough to start reasoning with yourself about things, immediately acquire more coffee.
 I ended up spending maybe two hours researching a way to issue SSL certificates on my Nginx Proxy Manager setup. Having an HTTPS connection is necessary to sign into Bitwarden (rightly so), and NPM has a service called Let’s Encrypt built in. Unfortunately, Let’s Encrypt is designed to work with a DNS provider such as Cloudflare.
 Cloudflare is capable of issuing something called a DNS challenge for a domain which, to be honest, I still don’t understand super well, aside from the fact that it allows someone hosting a site on that domain to prove they’re the rightful owner and not some malicious third-party.
 I do actually own the CNAME record for the domain I’m trying to set-up all my services on, but  here’s a fun fact about me: I’m very stubborn. And I have decided that this system is going to function entirely on my local network. So until I have received at least three separate sources of undeniable proof that is impossible, that’s the way it’s going to be.
 So, is it impossible?
 Based on some rough research, no. Right now I have Pihole acting as my DNS server, but for these purposes it might be more accurate to call it a DNS “resolver”; that is, it gets a request for a domain, checks its cache, and if it doesn’t have it, it goes upstream and gets it from a DNS “provider”, such as Cloudflare. The DNS “provider” is the entity with the ability to issue DNS challenges, which allow for HTTPS.
 What I have done so far is basically define a few domains that Pihole automatically sends IP addresses back for without checking its cache or upstream DNS provider. But to also issue DNS challenges for those domains, I need to run my own DNS “provider”, which Pihole will view as its upstream. This DNS “provider”, I can then configure to respond with a defined IP address for certain domains, but also to generate DNS challenges for said domains.

**4/23** <br/>
 Nothing so far, I’ll probably look into color manipulation for views in Kotlin. I guess Kotlin is just the language and the views are part of the Android SDK, but is Kotlin ever used for anything outside of Android development? I don’t think so.
