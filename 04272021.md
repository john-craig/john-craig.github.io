**4/26**<br/>
 What I have found is that there is actually a simpler approach to my previous issue with SSL certificates. As it turns out Nginx Proxy Manager has a menu for setting a custom certificate, rather than using Let’s Encrypt, which I believed to be the only available option.
This means I can create something called a Certificate Authority and make each of my devices trust the certificates it issues. This is an alternative to creating a self-signed certificate directly and having my devices trust that; the difference being that once the Certificate Authority is trusted, all the certificates it issues will also be trusted, whereas if I were to make a self-signed certificate, I would need to repeat the trusting process each time it renewed.
At least that’s my understanding.

<br/><br/>
**4/27**<br/>
 Now, a little more back-on-track. What I started looking into yesterday is Kotlin class called “Bitmap”. This class makes it possible to modify the colors of a resource file on a pixel-by-pixel basis, which is what I’m going to need to make the feature I have planned work.
 As I was going through the process of creating the sprites for the mobile game, I kept the palette I used to three or four very distinct colors. What I can do now is go over the image and map each of those colors to a palette.
 Supposed the palette I want to use is: lavendar, dark red, bright red. When this program finds a pixel with color 1 as its value, it would recolor it to lavendar; for color 2, dark red, and so on. This way I can decide what palettes I want to use without having to keep editing the sprites... and, not for nothing, it also meant I could make the sprites without needing to worry about what colors looked good.
 Now ontop of this recoloring process, I also want the actual palettes themselves to be generated by the game based on the temperature sensor. Maybe I want to associate 100 degrees with bright red. This would be the “base” color; I would then make the other colors in the palette a slightly darker version of that color, and a slightly lighter version of that color.
 If I wanted to get fancy I would increase the RGB value of the less-dominant colors in the color. For instance if bright red were the color, one other color in the palette would have its green increased to make it slightly more orange, and the other would have its blue increased to make it slightly more purple.
<br/><br/>

**4/28**<br/>
 Of course the first step in this whole process is getting images to recolor properly. As it happens this requires converting the ImageView being used into a Bitmap— a mutable Bitmap, specifically!— and then marching across its pixels and altering them as necessary.

 <br/><br/>
**4/29**<br/>
 And then after you have the ability to edit the Bitmap, you have to correctly identify the colors of the pixels to determine what needs to be changed. This is one of those exercises that demonstrates that Kotlin, in spite of its various amenities, is really just Java with a nice face of makeup.
That is to say, you just can’t get away from the nest of type casting and class conversions necessary to accomplish something reasonably complex. For instance, I have a few colors that I want to compare, and each of these is effectively four floating-points (red, green, blue, and alpha).
To get Kotlin to recognize these as colors I need to use a class called Color to convert these values into... as it happens, a signed integer. Then I can stop them in a Map structure with an enumerated type as the key. The reason for this is that when I construct the “palette” of colors, that will also be a Map structure with the same enumerated types; and so when replacing the colors in the bitmap, it will be a matter of matching up the enums.
But to replace the colors I first have to find them in the bitmap’s pixels. So I use a getPixel function that returns an unsigned integer, which I assume is packed the same way as the value I got back from the Color class. This would suggest that a direct comparison between the two would yield the right results, don’t you think?
You, like me, would be wrong.
So instead I have to use this same Color class to extract the individual red, green, and blue values from each pixel, and then compare that to the red, green, and blue values of my preset color constants.
Now this might be sufficient, except that— and this part is admittedly my fault— the images are very small, only twenty-by-twenty pixels, and so they get blown up when Kotlin runs. I was hoping the Bitmap class would allow me to interact with the original image rather than Kotlin’s blown-up representation, but this is not the case.
What this means is that the nice, neat colors of the pixels have bled together, and their values do not match the preset constants very well. Fortunately, I found a way to go through each preset and see which was the closest to the pixel’s actual color value, then determine the match based on that.
The end result isn’t exactly as nice as I want it to look, but I can also fix that by going into Gimp and making the images themselves bigger, which will help also.
<br/><br/>
**4/30**<br/><br/>
 Okay, Java rant aside, I do need to get this project completed. which means that I don’t have that much time to write about it.
